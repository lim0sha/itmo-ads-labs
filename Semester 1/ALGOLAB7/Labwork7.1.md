# Labwork №7.1 - Encryption
***
## Task A - "Двоичный код Грея"
Двоичный код Грея - способ перечисления всех
2^_**n**_ битовых строк из
_**n**_ бит таким образом, что при следующем перечислении изменяется только один бит, само изменения детерминировано (каждый бит в последовательности определенным образом изменяется при переходе от одного числа к следующему) и регулярно (каждое число в последовательности имеет одинаковое количество единичных битов)
### Input data:
На вход подается _**n**_ - порядок кода грея.
### Output data:
Необходимо вывести 2^_**n**_ строк, описывающих код Грея для _**n**_ бит.
### STDIN:
3
### STDOUT:
000\
001\
011\
010\
110\
111\
101\
100
***
## Task B - "Пусть утро будет нежным!"
Сидя у себя в офисе в Калифорнии, Марк Цукерберг чуть не подавился молочным латте без лактозы, когда увидел какое количество памяти занимают картинки с добрым утром вашей бабушки в WhatsApp. В скором порядке он созвал внезапную планерку талантливейших кодировщиков со всего мира, где единогласно пришли к решению о сжатии всех картинок через алгоритм LZ78.
### Input data:
Строка _**s**_ (|_**s**_| ≤ 5 * 10^5), состоящая из строчных латинских букв, обозначающая метаданные файла, который необходимо сжать.
### Output data:
На каждой новой строчке необходимо последовательно вывести список пар
_**pos**_ и _**next**_, где _**pos**_ - номер в словаре самого длинного найденного префикса и _**next**_ - символ, который следует за этим префиксом.
### STDIN:
abcaba
### STDOUT:
0 a\
0 b\
0 c\
1 b\
1
### STDIN:
abacababacabc
### STDOUT:
0 a\
0 b\
1 c\
1 b\
4 a\
0 c\
4 c
***
## Task C - "Облачный кризис"
Все презентации для лекций по АиСД хранятся на диске. Однако из-за обилия информации, размеры презентаций всё росли и росли, пока в какой-то момент на диске не закончилась память. Талантливые студенты предложили свою помощь и решили закодировать все презентации с помощью кода Хаффмана.
### Input data:
Дана строка _**s**_ из латинских букв нижнего регистра, которая представляет собой некоторый код презентации.
∣_**s**_∣ ≤ 10^6
### Output data:
Длина строки _**s**_, закодированной кодом Хаффмана.
### STDIN:
daccaba
### STDOUT:
13
***
## Task D - "Помогите Элли"
Ураган перенёс домик Элли в Волшебную страну, и чтобы вернуться домой, девочке нужна помощь великого волшебника Гудвина. Элли направляется в Изумрудный город, где тот самый Великий и Ужасный Гудвин живёт. Однако волшебника дома не оказалось. Тогда Элли рассказали про таинственный мессенджер EmeraldGram, при помощи которого можно связаться с Гудвином. К сожалению, в Волшебной стране нет хороших программистов, и задача реализовать дешифратор для EmeraldGram была не из простых, но девочка узнала, что сообщения там закодированны при помощи алгоритма Хэмминга. К счастью, у Элли оказался Ваш номер телефона, и она попросила Вас реализовать дешифратор для EmeraldGram. После передачи по сети необходимо определить, появилась ли какая-то ошибка из-за помех и, при возможности, восстановить сообщение. Помогите Элли связаться с Гудвином.
### Input data:
Первоя строка входных данных содержит целое число
1 ≤ _**t**_ ≤ 10^3 - количество строк. Далее следуют _**t**_ строк, закодированных алгоритмом Хэмминга.
### Output data:
Выведите _**t**_ раскодированных строк.
### STDIN:
3\
0000101011011\
01101010000100100\
01100100111001111001011001
### STDOUT:
010111011\
110100010010\
101011100111001011001\
### Additional info:
1) Битовый блок кодирования - это вся строка
2) Алгоритм Хэмминга: Контрольные биты располагаются в степенях двойки и изначально принимаются равными 0. Информационные биты (биты исходной последовательности) располагаются в прямом порядке. Поиск позиции с ошибкой происходит путём суммы позиций всех неверных контрольных битов (на основании их пересчёта). Алгоритм исправляет только одну ошибку на всю последовательность. Обнаружение дополнительных ошибок не предусмотрено. Разбиение на блоки не предусмотрено.
***
## Task E - "Тик-ток! Пост-Панк!"
Популярная девочка Саша с ИСа обожает записывать тик-токи для своих многочисленных подражателей. И вот одним воскресным вечером, отдыхая с друзьями, ее рука потянулась к новенькому айфону, чтобы в очередной раз порадовать поклонников новым контентом. К большому сожалению, память ее телефона оказалась совсем переполнена старыми видео, которые Саше совсем не хотелось удалять.

Добрые однокурсники подсказали блогерке сжать свои видео с помощью арифметического кодирования.
### Input data:
Строка _**s**_ (∣_**s**_∣ ≤ 10^5), состоящая из строчных латинских букв, обозначающая метаданные файла, который необходимо закодировать.
### Output data:
Результат кодирования строки _**s**_ с точностью до 6ого знака.
### STDIN:
abacaba
### STDOUT:
0.410849
### Additional info:
Примечание: при выборе ответа, необходимо взять левую границу возможных значений
***
## Task F - "Бедный Ваня"
Ваня всегда мечтал стать художником, но его работы были настолько посредственными, что никто не хотел их покупать. Тогда он решил, что станет арт-диллером, но найти достойных живописцев он не сумел, поэтому придумал мошшеническую схему с продажей копий работ известных художников, которые он выдавал за подлинники. В галерее, в которой работает Ваня, каждой картине соответствует уникальный код. Чтобы заработать больше денег, Ваня решил продавать работы Павлу Четверякову -- самому известному потомственному коллекционеру города. Друзья арт-диллеры рассказали Ване, что у Павла есть особый алгоритм, который определяет, является ли картина подлинником, и рассказали, как его можно обойти. Четверяков сравнивает уникальный код из собственной базы данных с кодом картины, которую собирается приобрести. Эти коды достались ему от дедушки, который записывал их вручную, поэтому некоторые из них не совсем корректны, поэтому Павел использует коэффициент
_**k**_, отвечающий за допустимое количество отличий от кода картины, которую он планирует купить. Если отличий меньше, чем
_**k**_, то он приобретает её к себе в коллекцию. Ване удалось раздобыть коды Павла. Помогите ему узнать, приобретёт ли коллекционер его работу.
### Input data:
В первой строке задаются три числа: _**n**_ < 5 * 10^6 (длина закодированного с
помощью RLE кода Павла Четверякова), _**m**_ < 5 * 10^6 (длина закодированного с помощью RLE кода картины Вани), _**k**_ < 5 * 10^9
(количество возможных отличий)
### Output data:
Вывести _**Yes**_, если Павел приобретёт картину, иначе вывести _**No**_.
### STDIN:
3 9 72\
X91\
m86H1e3l1
### STDOUT:
No
### STDIN:
8 23 1275\
q788x408\
e385p336J434Y26C2Z6X5Z2
### STDOUT:
Yes
### Additional info:
Незакодированная строка не содержит цифр.
***
## Task G - "Император Микки и его система защиты"
В империи ТИМО существует особая система передачи данных. Для защиты от чужих глаз используется RLE-сжатие, но есть нюанс, для еще большей защиты данные передаются в закодированном виде. Сам процесс де-шифрованния занимает долгое время, потому император Микки попросил Вас ему помочь.

Алгоритм де-шифрования таков:

Задается бинарное дерево на _**N**_ вершин. Вершина 1 является корнем. Каждая вершина имеет не более двух детей: левый ребенок имеет номер 2 * _**v**_, правый 2 * _**v**_ + 1 (при условии, что их номера не превосходят _**N**_). В каждой из вершин находится значение.

После происходят _**Q**_ изменений. Дается список из _**Q**_ целых чисел (_**k0**_, _**k1**_, _**k2**_, ..., _**kQ-1**_), где _**ki**_ номер вершины, относительно которой происходят изменения

Введем обозначения:
- _**р**_ - предок вершины _**v**_
- _**рр**_ - предок вершины _**p**_ (если таковые существуют)
- _**vl**_ - левый ребенок _**v**_, _**vr**_ - правый ребенок _**v**_
- _**pl**_ - левый ребенок _**р**_, _**pr**_ - правый ребенок _**р**_

В таком случае обмен задаётся следующими условиями:

Если _**р**_ - левый ребенок вершины _**рр**_, то _**v**_ становится левым ребенком _**рр**_, иначе - правым. \
Если _**v**_ - левый ребенок вершины _**р**_, то:
1. _**р**_ становится левым ребенком _**v**_
2. _**vr**_ остаётся правым ребенком _**v**_
3. _**vl**_ становится левым ребенком _**р**_
4. _**pr**_ остаётся правым ребенком _**р**_

<p align="center">
  <img src="https://pic.sort-me.org/428f4cf9-0710-442c-bf7a-42113bc1f1dd"/>
</p>
<p align="center">
  <img src="https://pic.sort-me.org/0dc880ca-4367-43d6-85b7-46c83cb64edd"/>
</p>

Аналогично, если _**v**_ - правый ребенок вершины _**р**_, то:
1. _**р**_ становится правым ребенком _**v**_
2. _**vl**_ остаётся левым ребенком _**v**_
3. _**vr**_ становится правым ребенком _**р**_
4. _**pl**_ остаётся левым ребенком _**р**_

<p align="center">
  <img src="https://pic.sort-me.org/ea83f66e-e830-40cd-ba3d-f901e5f955ea"/>
</p>
<p align="center">
  <img src="https://pic.sort-me.org/001c7dff-248b-4f6d-b0e2-1e770c5afd4e"/>
</p>

Если вершина, относительно которой должно пройти изменение, является корнем дерева, то изменение не происходит\
Далее делается _**LRV(v)**_ обход получившегося дерева и номер вершин записываются на листочек.\
Такой алгоритм дешифрования необходимо применить как для чисел-коэффициентов повторения символов, так и для самих символов.\
После дешифрования данных их следует разжать используя принцип _**RLE**_-сжатия. _**і**_-ое число в обходе дерева коэфицентов соответствует _**і**_-ой букве в обходе дерева символов.

Замечание - гарантируется, что количество символов и коэффициентов одинаковы. Алфавит символов - английский алфавит.\
(1 ≤ _**N**_ ≤ 10^6)\
(1 ≤ _**Qi**_ ≤ 5 * 10^3)

### Input data:
1-я строка содержит два целых числа _**N**_ и _**Q1**_ - количество вершин и
количество изменений в дереве для чисел-коэффициентов\
2-я строка содержит _**N**_ целых чисел (коэффициенты)\
З-я строка содержит _**Q1**_ целых чисел (_**k1i**_ число - изменение относительно вершины _**і**_)\
4-я строка содержит два целых числа _**N**_ и _**Q2**_ - количество вершин и
количество изменений в дереве для символов\
5-я строка содержит _**N**_ символов заданных через пробел\
6-я строка содержит _**Q2**_ целых чисел (_**k2i**_ число - изменение относительно вершины _**i**_)
### Output data:
Выведите дешифрованную и разжатую строку символов.
### STDIN:
4 3\
11 11 11 9\
3 4 3\
4 4\
I T M O\
4 1 3 2
### STDOUT:
OOOOOOOOOOOTTTTTTTTTIIIIIIIIIIIMMMMMMMMMMM
***