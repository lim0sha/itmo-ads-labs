# Labwork №5 - BST
***
## Task A - "Ёлки-палки 2.0"
Несмотря на все ваши старания, новогодняя бинарная ёлка в ИТМО все равно упала. Недолго думая, руководство решило обратиться за помощью к уважаемым коллегам из нового физтеха. Проведя расчеты и эксперименты, физики предложили вам такое решение - сделать из обычного бинарного дерева бинарное дерево поиска и нарядить дерево так, чтобы никакие две ветки не отличались высотой более чем на 1.

### Input data:
В первой строчке дано _**n**_ (1 ≤ _**n**_ ≤ 10^6) - количество вершин.\
Во второй строчке дано _**n**_ чисел (-10^9 ≤ _**ai**_ ≤ 10^9), разделенных пробелом, - количество украшений в вершине дерева, отсортированных по возрастанию. Также не существует двух таких вершин, количества украшений которых одинаковы.

### Output data:
Вывести бинарное дерево через preorder обход. В случае нескольких возможных ответов нужно вывести тот, в котором корень каждого поддерева минимально возможный.

### STDIN:
5\
-10 -3 0 5 9
### STDOUT:
0 -10 -3 5 9
***
## Task B - "Предки - наше всё"
Компания ООО "Предки — наше всё" занимается построением генеалогического древа. Так оказалось, что вместо стажировки в Яндексе вы решили пойти работать в эту компанию для того, чтобы оплатить свое образование. К несчастью, данные в древе ваших клиентов постоянно меняются, поэтому часто приходится его редактировать. Удивительным образом вы заметили, что генеалогическое древо для каждого клиента является бинарным деревом, и в графе значение является возраст человека. Вам нужно добавить нового человека в древо и ускорить процесс заполнения поисков, вы реализуете весь процесс редактирования и трассировку с полным поисковым деревом, поддерживая его.

- `insert x` — добавить нового человека с возрастом x в древо. Если в дереве уже есть человек с возрастом x, то добавлять нового не надо.
- `delete x` — удалить из древа человека с возрастом x. Если человека с возрастом x в дереве нет, ничего делать не надо.
- `exists x` — проверить, есть ли человек с возрастом x в дереве, вывести "true", если есть, иначе — "false".
- `next x` — вывести минимальный возраст в дереве, строго больший x, или "none", если такого нет.
- `prev x` — вывести максимальный возраст в дереве, строго меньший x, или "none", если такого нет.

В древо помещаются и извлекаются только целые числа, не превышающие по модулю 10^9.

### Input data:
Операций с древом, их количество не превышает 100.

### Output data:
Выведите последовательно результат выполнения всех операций _exists_, _next_, _prev_. Каждый ответ на новой строчке.

### STDIN:
insert 2\
insert 5\
insert 3\
exists 2\
exists 4\
next 4\
prev 4\
delete 5\
next 4\
prev 4

### STDOUT:
true\
false\
5\
3\
none\
3
***
## Task C - "И здесь K-ый максимум..."
Бабушка Дуся вернулась с невероятного приключения к себе домой в деревню. За время ее отдыха, яблоня в огороде выросла и стала плодоносить. Из-за своей привязанности и любви к дереву, она внимательно следила за каждым появившимся яблоком и научилась на глаз определять его вес. Своим талантом она известна на всю деревню, поэтому соседи, желая проверить ее, просили назвать
_**k**_-й максимум среди весов всех яблок, находящихся на дереве.

### Input data:
На первой строчке находится число _**n**_ (1 ≤ _**n**_ ≤ 10^5) - количество команд\
Далее на _**n**_ строчках идут команды трех типов:\
1 _**k**_ - появляется новое яблоко с весом _**k**_\
0 _**k**_ - бабушку просят назвать _**k**_-й максимум\
-1 _**k**_ - яблоко с весом _**k**_ падает с дерева\
|_**k**_| ≤ 10^9

### Output data:
На каждую просьбу соседей вывести _**k**_-ый максимум

### STDIN:
11\
1 5\
1 3\
1 7\
0 1\
0 2\
0 3\
-1 5\
1 10\
0 1\
0 2\
0 3

### STDOUT:
7\
5\
3\
10\
7\
3
### Additional info:
Вес яблока с момента появления не меняется.\
Яблоки, упавшие с дерева, остаются там навсегда
***

## Task D - "Ёлки-палки"
На Новый год в ИТМО возле входа в вуз ставится большая красиво украшенная ёлка. Прошлый год не был исключением, но поскольку ИТМО первый неклассический вуз, то вместо обычной ёлки решили установить ёлку в виде бинарного дерева, где в каждой вершине свое количество украшений согласно свойствам бинарного дерева. К сожалению, со временем дерево накренилось вправо, из-за чего было принято решение снять самые правые украшения на каждом уровне.

### Input data:
Первая строчка _**n**_ (1 ≤ _**n**_ ≤ 10^3) - количество вершин в дереве\
Вторая строчка - _**n**_ чисел (-10^9 ≤ _**ai**_ ≤ 10^9), задающие количество
украшений в каждой вершине дерева построенного через последовательный
_insert_.

### Output data:
Вывести через пробел количество украшений самых правых вершин на каждом уровне, начиная с 1
### STDIN:
11\
100 50 20 19 18 17 25 24 57 160 110
### STDOUT:
100 160 110 25 24 17
***

## Task E - "Три друга"
Три друга списывают лабораторную работу, каждый из них списывает по
_**n**_ различных задач. Поскольку друзья не очень умные, они не меняют названия отправляемых на проверку файлов.

По истечении времени, отведенного на написание лабораторной, преподаватель запускает бан-машину и ставит баллы по следующим правилам:

- если задача написана только у одного студента, то этот студент получает 3 балла, поскольку эту задачу он не списывал и не давал списывать;
- если задача списана ровно у двух студентов, то каждый из них получает по 1 утешительному баллу;
- если задача списана всеми тремя студентами, то за нее баллы не начисляются никому.
Выведите финальное количество баллов у каждого студента.

В рамках этой задачи будем считать, что Бан-машина считает решения списанными, если у них полностью совпадают имена файлов.
### Input data:
В первой строке входных данных дается число _**n**_ (1 ≤ _**n**_ ≤ 10000) - количество задач в лабораторной.

Следующие три строки содержат по _**n**_ различных слов в каждой — названия файлов с решениями, отправленных каждым из студентов.
### Output data:
Необходимо вывести 3 числа - количество баллов у первого, второго и третьего студента соответственно.
### STDIN:
3\
fir sec thi\
thi fir sec\
aaa sec bbb

### STDOUT:
2 2 6
### Additional info:
Решения, написанные при помощи сортировок, бинарного поиска или встроенных деревьев не засчитываются. Set, Map и т.п. - запрещены.

В реальности бан-машина работает намного сложнее ;)
***

## Task F - "Подельник"
Тяжело себе представить более несчастного человека, чем тот, кто планировал заботать предмет за ночь перед экзаменом и не преуспел в этом. Именно такая беда приключилась с незадачливым студентом Славой, поэтому он отлетел на допсу по алгоритмам. Во второй раз Слава решил не рисковать и попросил вас помочь ему закрыть этот ужасный предмет (готовиться заранее
− удел слабых).

Наступил день экзамена. Славе повезло, так как у экзаменатора в этот день было хорошее настроение. Преподаватель нарисовал перед ним бинарное дерево поиска и попросил написать порядок вывода вершин при каждом виде обхода этого дерева. Слава записал три строчки чисел и отправил их вам на проверку. Ваша задача
− написать программу, проверяющую корректность результатов Славы. Другими словами, может ли существовать дерево с таким порядком вершин при обходах. Помогите Славе, его жизнь в ваших руках!

### Input data:
В первой строке записано число
_**n**_ ≤ 10^7 − количество вершин в дереве. В следующих 3 строках записаны по _**n**_ чисел - результаты
_pre−_, _in−_ и _post−_ _order_ обхода дерева соответственно.
### Output data:
В единственной строке выведите _**YES**_ при валидности обходов и _**NO**_ в обратном случае.

### STDIN:
6\
3 2 1 5 4 6\
1 2 3 4 5 6\
1 2 4 6 5 3
### STDOUT:
YES

### STDIN:
6\
3 2 1 5 4 6\
1 2 3 4 5 6\
1 6 2 5 3 4
### STDOUT:
YES

### STDIN:
6\
3 2 1 9 4 6\
1 2 3 4 5 6\
1 2 4 6 5 3
### STDOUT:
NO
### Additional info:
При равенстве значений вершин дерева одинаковые значения находятся в правом поддереве
***

## Task G - "Всё давай. Я очень занятой."
Денис − очень занятой человек. Поэтому он нанял Вас, чтобы оптимизировать свои жизненные процессы.

Самое важное для Дениса − это саморазвитие, из-чего для каждого дня он составляет расписание в виде бинарного дерева, каждая вершина которого − это польза от завершения некоторой работы в течение дня.

Чтобы получать максимальную пользу от каждой минуты своего драгоценного времени, Денис ищет в своем расписании оптимальный участок для работы. Таковым он называет поддерево, которое является BST с максимальной пользой.
### Input data:
_l_ - спуск в левого ребёнка\
_r_ − спуска в правого ребёнка\
_u_ - подъём наверх

В единственной строке подается _**n**_ значений.

### Output data:
Вывести в единственной строке число − максимальную пользу

### STDIN:
1 l 4 l 2 u r 4 u u r 3 l 2 u r 5 l 4 u r 6 u u u u
### STDOUT:
20

### STDIN:
4 l 3 l 1 u r 2 u u u
### STDOUT:
2

### STDIN:
-4 l -2 u r -5 u u
### STDOUT:
0
***

## Task H - "Может ты скажешь ей, что ты не Леонтий?"
Недавно вошедшие в список форбс 24 до 24-ех Леонид и Семен решили
открыть новый бизнес. Для
этого они нашли знаменитую
предпринимательницу Лизу, которая стала спонсором их стартапа. Для
успешного трейдинга ребята создали один основной аккаунт и один
дополнительный.

Для хорошей отчетности перед инвестором все рискованные сделки они
проводят со второго аккаунта. Как только второй аккаунт выходит в
положительный баланс, то ребята сливают все акции на основной аккаунт, а
второй портфель очищается.

Вы - первый разработчик в их стартапе, перед Вами стоит сложная задача
реализации придуманной Семой и Лёвой системы.

С аккаунтами могут происходить следующие операции:

- `buy account id` - купить акции с номером _id_ в портфель account (может
быть для обоих аккаунтов)
- `sell account id` - продать акции с номером _id_ в портфели account (может
быть для обоих аккаунтов)
- `merge` - сливать все акции в основной портфель.
После каждого объединения товарищи проводят показ результатов Лизе, поэтому при этой операции требуется выводить _id_ акций в отсортированном виде без пробела на конце.

### Input data:
В первой строке подается **_n_** — число операций 1 ≤ **_n_** ≤ 10^7

В следующих _**n**_ строках подаются команды одного из 3 видов (_buy_, _sell_, _merge_)\
Гарантируется, что номер акции: 0 ≤ _**id**_ ≤ 10^9

### Output data:
При каждой операции _merge_ вывести _id_ акции в отсортированном виде
### STDIN:
1\
buy 1 1
### STDOUT:

### STDIN:
2\
buy 1 2\
merge
### STDOUT:
2
### Additional info:
Если портфель пуст, то выводить ничего не требуется.
***
