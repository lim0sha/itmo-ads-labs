# Labwork №6 - AVL

***

## Task A - "Проверка сбалансированности"

АВЛ-дерево является сбалансированным в следующем смысле: для любой вершины высота ее левого поддерева отличается от высоты ее правого поддерева не больше, чем на единицу.

Введем понятие баланса вершины: для вершины дерева **_V_** ее баланс **_B(V)_** равен разности высоты правого поддерева и высоты левого поддерева.

Таким образом, свойство АВЛ-дерева, приведенное выше, можно сформулировать следующим образом: для любой ее вершины **_V_** выполняется следущее неравенство: -1 ≤ **_B(V)_** ≤ 1.

Дано двоичное дерево поиска. Для каждой его вершины требуется определить ее баланс.

### Input data:

Входные данные содержать описание двоичного дерева.

В первой строке файла находится число **_n_** (1 ≤ **_n_** ≤ 2•10^5) — число вершин в дереве. В последующих **_n_** строках файла находятся описания вершин дерева. В (**_i+1_**)-ой строке файла (1 ≤ **_i_** ≤ n) находится описание **_i_**-ой вершины, состоящее из трех чисел **_K_i_**, **_L_i_**, **_R_i_**, разделенных пробелами, ключа в **_i_**-ой вершине (|**_K_i_**| ≤ 10^9), номера левого ребенка **_i_**-ой вершины (**_i_** < **_L_i_** ≤ **_n_** или **_L_i_** = 0, если левого ребенка нет) и номера проавго ребенка **_i_**-ой вершины (**_i_** < **_R_i_** ≤ **_n_** или **_R_i_** = 0, если правого ребенка нет).

Все ключи различны. Гарантируется, что данное дерево является деревом поиска.


### Output data:

Для **_i_**-ой вершины в **_i_**-ой строке выведите одно число — баланс данной вершины.

### STDIN:

6\
-2 0 2\
8 4 3\
9 0 0\
3 5 6\
0 0 0\
6 0 0

### STDOUT:

3\
-1\
0\
0\
0\
0
***

## Task B - "Делаю я левый поворот"

Для балансировки АВЛ-дерева при операциях вставки и удаления производятся левые и правые повороты. Левый поворот в вершине производится, когда баланс этой вершины больше 1, аналогично, правый поворот производится при балансе, меньшем 1.

Существует два разных левых (как, разумеется, и правых) поворота: большой и малый левый поворот.

Малый левый поворот осуществляется следующим образом:

{скоро тут будет иллюстрация}

Заметим, что если до выполнения малого левого поворота был нарушен баланс только корня дерева, то после его выполнения все вершины становятся сбалансированными, за исключением случая, когда у правого ребенка корня баланс до поворота равен 1. В этом случае вместо малого левого поворота выполняется большой левый поворот, который осуществляется так:

{скоро тут будет иллюстрация}

Дано дерево, в котором баланс дерева равен 2. Сделайте левый поворот.

### Input data:

Входные данные содержать описание двоичного дерева.

В первой строке файла находится число **_n_** (1 ≤ **_n_** ≤ 2•10^5) — число вершин в дереве. В последующих **_n_** строках файла находятся описания вершин дерева. В (**_i+1_**)-ой строке файла (1 ≤ **_i_** ≤ n) находится описание **_i_**-ой вершины, состоящее из трех чисел **_K_i_**, **_L_i_**, **_R_i_**, разделенных пробелами, ключа в **_i_**-ой вершине (|**_K_i_**| ≤ 10^9), номера левого ребенка **_i_**-ой вершины (**_i_** < **_L_i_** ≤ **_n_** или **_L_i_** = 0, если левого ребенка нет) и номера проавго ребенка **_i_**-ой вершины (**_i_** < **_R_i_** ≤ **_n_** или **_R_i_** = 0, если правого ребенка нет).

Все ключи различны. Гарантируется, что данное дерево является деревом поиска. Все ключи различны. Баланс корня дерева (вершины с номером 1) равен 2, баланс всех остальных вершин находится в пределах от -1 до 1.

### Output data:

Выведите в том же формате дерево после осуществления левого поворота. Нумерация вершин может быть произвольной при условии соблюдения формата. Так, номер вершины должен быть меньше номера ее детей.

### STDIN:

7\
-2 7 2\
8 4 3\
9 0 0\
3 5 6\
0 0 0\
6 0 0\
-7 0 0

### STDOUT:

7\
3 2 3\
-2 4 5\
8 6 7\
-7 0 0\
0 0 0\
6 0 0\
9 0 0
***

## Task C - "Вставка в АВЛ-дерево"

Вставка в АВЛ-дерево вершины **_V_** с ключом **_X_** при условии, что такой вершины в этом дереве нет, осуществляется следующим образом:
- находится вершина **_W_**, ребенком которой должна стать вершина **_V_**
- вершина **_V_** делается ребенком вершины **_W_**
- производится подъем от вершины **_W_** к корню, при этом, если какая-то из вершин несбалансирована, производится, в зависимости от значения баланса, левый или правый поворот.

Первый этап нуждается в пояснении. Спуск до будущего родителя вершины **_V_** осуществляется, начиная от корня, следующим образом:

Пусть ключ текущей вершины равен **_Y_**.
- Если **_X_** < **_Y_** и у текущей вершины есть левый ребенок, переходим к левому ребенку.
- Если **_X_** < **_Y_** и у текущей вершины нет левого ребенка, то останавливаемся, текущая вершина будет родителем новой вершины.
- Если **_X_** < **_Y_** и у текущей вершины есть правый ребенок, переходим к правому ребенку.
- Если **_X_** < **_Y_** и у текущей вершины нет правого ребенка, то останавливаемся, текущая вершина будет родителем новой вершины.

Отдельно рассматривается следующий крайний случай если до вставки дерево было пустым, то вставка новой вершины осуществляется проще: новая вершина становится корнем дерева.



### Input data:

Входные данные содержать описание двоичного дерева.

В первой строке файла находится число **_n_** (1 ≤ **_n_** ≤ 2•10^5) — число вершин в дереве. В последующих **_n_** строках файла находятся описания вершин дерева. В (**_i+1_**)-ой строке файла (1 ≤ **_i_** ≤ n) находится описание **_i_**-ой вершины, состоящее из трех чисел **_K_i_**, **_L_i_**, **_R_i_**, разделенных пробелами, ключа в **_i_**-ой вершине (|**_K_i_**| ≤ 10^9), номера левого ребенка **_i_**-ой вершины (**_i_** < **_L_i_** ≤ **_n_** или **_L_i_** = 0, если левого ребенка нет) и номера проавго ребенка **_i_**-ой вершины (**_i_** < **_R_i_** ≤ **_n_** или **_R_i_** = 0, если правого ребенка нет).

Все ключи различны.Гарантируется, что данное дерево является корректным АВЛ-деревом.

В последней строке содержится число **_X_** (|**_X_**| ≤ 10^9) ключ вершины, которую требуется вставить в дерево. Гарантируется, что такой вершины в дереве нет.

### Output data:

Выведите в том же формате дерево после осуществления левого поворота. Нумерация вершин может быть произвольной при условии соблюдения формата. Так, номер вершины должен быть меньше номера ее детей.

### STDIN:

2\
3 0 2\
4 0 0\
5

### STDOUT:

3\
4 2 3\
3 0 0\
5 0 0


***

## Task D - "Очистка телефона"

У Пети в телефоне записаны номера друзей. Однажды Петя заметил, что у него кончается свободная память на устройстве. Петя знал, что среди его контактов есть множество дубликатов. Он решил удалить повторяющиеся записи.

Каждый контакт - это строка, состоящая исключительно из строчных или заглавных букв латинского алфавита и цифр. При удалении строки освобождается **_M_** байт памяти, где **_M_** — количество различных символов в данной строке. Помогите Пете узнать, сколько памяти в байтах он сможет освободить.


### Input data:

В первой строке входных данных дается число **_n_** (1 ≤ **_n_** ≤ 10^5) — количество контактов в телефоне.

В следующей строке записаны через пробел **_n_** строк — контакты Пети.

### Output data:

Выведите одно число - ответ на задачу.

### STDIN:

5\
qqwe qqwe abc s s

### STDOUT:

4


### Additional info:

Решения, написанные при помощи сортировок, бинпоиска или встроенных деревьев, структур данных `set`, `map` и прочих - не засчитываются.

***

## Task E - "Три друга 2: возвращение"

Три друга списывают лабораторную работу, каждый из них списывает по 
n
n различных задач. Поскольку друзья не очень умные, они не меняют названия отправляемых на проверку файлов.

По истечении времени, отведенного на написание лабораторной, преподаватель запускает бан-машину и ставит баллы по следующим правилам:

- если задача написана только у одного студента, то этот студент получает 3 балла, поскольку эту задачу он не списывал и не давал списывать;
- если задача списана ровно у двух студентов, то каждый из них получает по 1 утешительному баллу;
- если задача списана всеми тремя студентами, то за нее баллы не начисляются никому.

Выведите финальное количество баллов у каждого студента.

В рамках этой задачи будем считать, что Бан-машина считает решения списанными, если у них полностью совпадают имена файлов.

### Input data:

В первой строке входного файла содержится число **_n_** (1 ≤ **_n_** ≤ 100000) — количество задач в лабораторной.

Следующие три строки содержат по **_n_** различных слов в каждой — названия файлов с решениями, отправленных каждым из студентов.

### Output data:

Необходимо вывести 3 числа - количество баллов у первого, второго и третьего студента соответственно.

### STDIN:

3\
fir sec thi\
thi fir sec\
aaa sec bbb

### STDOUT:

2 2 6

### Additional info:

Решения, написанные при помощи сортировок, бинпоиска или встроенных деревьев не засчитываются. Set, Map и т.п. - запрещены.

В реальности бан-машина работает намного сложнее ;)

***

## Task F - "Детектив"

В городе **_N_** произошла серия преступлений, расследовать которую пригласили опытного детектива Шерлока Толмса. Он с радостью принялся за новое интересное дело, но не учел, что в этот раз улик оказалось слишком много, и все они имеют совершенно разный "вес" для проведения расследовния.

Шерлок нашел в телефонной книжке номер самого талантливого программиста в городе, которым оказались Вы, и обратился за помощью. Обладая знаниями алгоритмов и структур данных и проанализировав ситуацию, Вы решили хранить все зацепки в виде АВЛ-дерева, чтобы при необходимости достаточно быстро находить любой объект, при этом учитывая вес каждого свидетельства.

Во время расследования дела, Вам предстоит не только добавлять новые улики, но и удалять те, которые уже потеряли актуальность, а также проверять наличие определенных улик. К сожалению, не все знают как работает АВЛ-дерево, поэтому коллеги попросили Вас выводить баланс дерева после каждой операции вставки и удаления.


### Input data:

В первой строке находится число **_n_** (1 ≤ **_n_** ≤ 2 • 10^5) — число операций. Изначально улик нет. В каждой из последующих **_n_** строк находится описание одной из трех операций:
- **_A x_** — поместить улику с весом **_x_** в дерево. Если она уже была добавлена, операция игнорируется.
- **_D x_** — удалить потерявшую актуальность улику, которая имеет вес **_x_**. Если такой нет, операция игнорируется.
- **_C x_** — проверить наличие улики с весом **_x_**.

### Output data:

Для каждой операции вида **_C x_** выведите **_Y_**, если такая улика содержится в дереве, и **_N_**, если не содержится.

Для каждой операции вида **_A x_** или **_D x_** выведите баланс корня дерева после выполнения операции.

Если дерево пустое (в нем нет вершин), выведите 0.

Вывод для каждой операции должен содержаться на отдельной строке.

### STDIN:

6\
A 3\
A 4\
A 5\
C 4\
C 6\
D 5

### STDOUT:

0\
1\
0\
Y\
N\
-1


### Additional info:

Операции вставки и удаления требуется реализовать точно так же, как это было сделано в предыдущих задачах, потому что в ином случае баланс корня может отличаться от требуемого.

***

